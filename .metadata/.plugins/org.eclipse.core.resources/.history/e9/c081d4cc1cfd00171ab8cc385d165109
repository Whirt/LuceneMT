
import java.io.IOException;
import java.nio.file.Paths;

import org.apache.lucene.analysis.Analyzer;
import org.apache.lucene.analysis.standard.StandardAnalyzer;
import org.apache.lucene.document.Document;
import org.apache.lucene.index.DirectoryReader;
import org.apache.lucene.index.IndexReader;
import org.apache.lucene.queryparser.classic.ParseException;
import org.apache.lucene.queryparser.classic.QueryParser;
import org.apache.lucene.search.IndexSearcher;
import org.apache.lucene.search.Query;
import org.apache.lucene.search.ScoreDoc;
import org.apache.lucene.search.TopDocs;
import org.apache.lucene.search.similarities.BM25Similarity;
import org.apache.lucene.search.similarities.ClassicSimilarity;
import org.apache.lucene.store.FSDirectory;

import GUI.Window;
import LuceneIndexing.DocFields;

/* Lucene Models and Tolerant retrieval test on sMarT benchmark
 * 
 * Apache Lucene è un pacchetto Java per sistemi d'information retrieval. 
 * Supporta l'indexing, quindi pre-processing e la creazione/uso di modelli di 
 * information retrieval per fare searching e ranking offrendo anche diverse 
 * tecniche di Tolerant retrieval, il tutto è ottimizzato per ottenere alte 
 * prestazioni. Inoltre nel caso non bastassero supporta anche la 
 * personalizzazione/creazione di nuovi modelli di ranking e tipologie di query. 
 * 
 * Questo progetto mira alla presentazione del pacchetto Lucene vers. 7.2.1
 * in particolare vuole permettere all'utente di testare i modelli classici
 * di IR offerti dalla libreria, mettere in luce le tecniche di tolerant
 * retrieval supportate e fornire dati per la valutazione della Precision
 * e Recall tramite lo SMART Benchmark.
 * 
 * Data: Gennaio 2017
 * Autore: Hu Jia Cheng
 */
public class LuceneMT {

	public static void main(String[] args) {
		System.out.println("Starting LuceneMT...");
		///indow wn = new Window();
		/*
		// Reading
		IndexReader reader;
		try {
			reader = DirectoryReader.open(
					FSDirectory.open(Paths.get("./indexes/SMART/ADI"))
					);
		IndexSearcher searcher = new IndexSearcher(reader);
		Analyzer analyzer = new StandardAnalyzer();
		searcher.setSimilarity(new ClassicSimilarity());
		QueryParser parser = new QueryParser(DocFields.content.toString(),analyzer);
		Query query = parser.parse("computer");
		
		System.out.println("Searching for: "+query.toString(DocFields.content.toString()));
		
		TopDocs results = searcher.search(query, 5*10);

		System.out.println("1");
		ScoreDoc[] hits = results.scoreDocs;

		System.out.println("2");
		int totalHits = Math.toIntExact(results.totalHits);
		
		// storing in result doc
		System.out.println("Printing results...");
		Document[] resultDoc = new Document[hits.length];
		
		System.out.println("TotalHits:"+totalHits);
		System.out.println("Hits len:"+hits.length);
		for (int i = 0 ; i < hits.length ; i++) {
				System.out.println("hits["+i+"].doc:"+hits[i].doc);
				resultDoc[i] = searcher.doc(hits[i].doc);
				String id = resultDoc[i].get(DocFields.id.toString());
				String author = resultDoc[i].get(DocFields.author.toString());
				String title = resultDoc[i].get(DocFields.title.toString());
				if (id != null) System.out.println("id:"+id);
				if (author != null) System.out.println("author:"+author);
				if (title != null) System.out.println("title:"+title);
			
		}
		
		} catch (IOException | ParseException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		*/
	}
}
